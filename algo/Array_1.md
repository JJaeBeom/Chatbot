# 20230202

## 카운팅 정렬()

- 항목들의 순서를 결정하기 위해 집합에 각 항목이 몇 개씩 있는지 세는 작업을 하여, 선형 시간에 정렬하는 효율적인 알고리즘

- 제한 사항
  
  - **정수나 정수로 표현할 수 있는 자료**(인덱스는 소숫점은 안되니까~~)에 대해서만 적용 가능 : 각 항목의 발생 회수를 기록하기 위해, 정수 항목으로 인덱스 되는 카운트들의 배열을 사용하기 때문이다.
  
  - 카운트들을 위한 충분한 공간을 할당하려면 집합 내의 가장 큰 정수를 알아야 한다.

- 시간 복잡도
  
  - O(n+k) : n은 리스트 길이, k는 정수의 최대값 /k가 어마어마하게 커질 수 있다.

[0] * 100만까지 가능, 1억 막 이런건 다른 방법을 찾아

```python
#[0, 4, 1, 3, 1, 2, 4, 1]을 카운팅 정렬하는 과정
# 1단계 - data(0~4)에서 각 항목들의 발생회수를 세고,
# 정수 항목들로 직접 인덱스 되는 카운트 배열 counts에 저장
# 0 4 1 3 1 2 4 1 
# 0 0 0 0 0 ↓ # [0] * 5
# 1 3 1 1 2 (0이 1번 / 1이 3번 - - -)

# 누적하고 싶을땐? 정렬된 집합에서 각 항목의 앞에 위치할 항목의 개수를 반영하기 위해 counts의 원소를 조정한다.
# 1 3 1 1 2 
# 1 4 5 6 8
# 1 4(3+1) 5(4+1) 6(5+1) 8(6+2)
# for i : 1 -> 4
# counts[i] = counts[i - 1] + counts[i]

#counts[1]을 감소시키고 Temp에 1을 삽입한다.
# 0 4 1 3 1 2 4 1(<<<)
# 1 3(4-1) 5  6  8  # 0~1까지 4개가 있는데, 
# 0 0      0  1  0  0  0  0 # 그럼 마지막 4번째는 1이겠네? 그럼 0~4까지 숫자가 8개가 있는데 마지막 8번째칸은 4겠네? 
# 1 3 5 6 7(8-1)
# 0 0 0 1 0 0 0 4
# 쭉 반복하면 
# 0 1 1 1 2 3 4 4 가 된다.
```

```python
def Counting_Sort(A, B, K)
# A[] -- 입력 배열(O to k)  << DATA
# B[] -- 정렬된 배열 << TEMP
# C[] -- 카운트 배열 << Counts
  c = [0] * (k+1) # << 배열만들기 k는  A에서 가져옴
  for i in range(0, len(A)): #lenA = n# for x in A:
    C[A[i]] += 1             #   # C(x) += 1
  for i in range(1, len(C)):#len(C)=k+1 카운트배열의 크기
      C[i] += C[i-1]
  for i in range(len(B)-1, -1, -1):
      C[A[i]] -= 1
      B[C[A[i]]] = A[i]
```

## Baby-gin Game

- 설명
  - 0~9 사이의 숫자 카드 사이에서 임의의 카드 6장을 뽑았을 때, 3장의 카드가 연속적인 번호를 run이라 하고, 3장의 카드가 동일한 번호를 갖는 경우를 triplet이라고 한다.
  - 그리고, 6장의 카드가 run과 triplet로만 구성된 경우를 baby-gin으로 부른다.
  - 6자리의 숫자를 입력 받아 baby-gin 여부를 판단하는 프로그램을 작성하라
- 입력 예
  - 667767은 두개의 트리플릿이므로 베이비진이다. 666 777
  - 054060은 한개의 런과 한개의 트리플릿이므로 베이비진이다.456 000
  - 101123은 한개의 트리플릿이 존재하나 023이 런이 아니므로 베이비진이 아니다x 
- 6자리의 숫자를 입력받아 어떻게 베이비진 여부를 찾을것인가
  
  ## 완전검색
- 완전검색방법은 문제의 해법으로 생각할수있는 모든 경우의 수를 나열해보고 확인하는 기법.
- Brute-force 혹은 generate-and-test라고도 부름
- 일반적으로 경우의수가 적을때 유용.

## 완전 검색을 활용한 Baby-gin접근

- 고려할 수 있는 모든 경우의 수 생성
  
  - 6개의 숫자로 만들 수 있는 모든 숫자 나열(중복 포함)
  - 예)입력으로 [2, 3, 5, 7, 7, 7]을 받았을 경우, 아래와 같이 순열을 생성할 수 있다.
    2 3 5 7 7 7
    2 3 7 5 7 7 . . . . . .

- 해답 테스트하기
  
  - 앞의 3자리와 뒤의 3자리를 잘라, run과 트리플릿 여부를 테스트 후 최종적으로 베이비진 판단.
  
  ## 순열
  
  - 순열
  - 서로 다른 것들 중 몇 개를 뽑아서 한 줄로 나열하는 것
  - 서로 다른 n개 중 r개를 택하는 순열은 아래와 같이 표현
    - nPr
  - 그리고 nPr은 다음과 같은 식이 성립
    - nPr = n * (n-1) * (n-2) *...* (n-r+1) 
       근데 총 항의 갯수는 r개가 된다. 사실 n-0부터 가는거라 +1 해줘야한다?
  - nPn = n!이라고 표기하며 Factorial이라 부른다. 
    주어진거 다쓰는 경우
    - n! = n * (n-1) * (n-2) *...* 2 * 1

## 단순하게 순열을 생성하는 방법

- 예){1, 2, 3}을 포함하는 모든 순열을 생성하는 함수
  - 동일한 숫자가 포함되지 않았을 때, 
    
    ```python
    for i1 in range(1, 4):
    for i2 in range(1, 4):
      if i2 != i1:
        for i3 in range(1, 4):
          if i3 != i1 and i3 != i2 :
            print(i1, i2, i3)
    ```
    
    ## 탐욕(Greedy) 알고리즘
- 탐욕 알고리즘은 최적해를 구하는 데 사용되는 근시안적인 방법
- 여러 경우 중 하나를 결정해야 할 때마다 그 순간에 최적이라고 생각되는 것을 선택해 나가는 방식으로 진행하여 최종적인 해답에 도달한다.
- 각 선택의 시점에서 이루어지는 결정은, 지역적으로는 최적이지만 그 선택들이 모여 최종 해답이 최적이라는 보장은 없다.
- 일반적으로, 머릿속에 떠오르는 생각을 검증 없이 바로 구현하면 그리디.

## 탐욕 알고리즘의 동작 과정

1) 해 선택: 현재 상태에서 부분 문제의 최적 해를 구한 뒤, 이를 부분해집합(Soultuin Set)에 추가한다.
2) 실행 가능성 검사: 새로운 부분해 집합이 실행 가능한지를 확인한다. 곧, 문제의 제약조건을 위한하지 않는지를 검사
3) 해 검사: 새로운 부분해집합이 문제의 해가되는지 확인. 아직 안되면 1부터 다시 시작

## 탐욕 알고리즘 예

- 거스름돈 줄이기
  - 단위가 가장 큰 동전으로 거스름돈에 추가
  - 실행가능성 검사
  - 해 검사
    다음에 마저

## Baby-gin 풀이

- 완전검색이 아닌 방법으로 풀어보자
  - ex)444345
    N-M (10-3)

```python
i = 0
tri = run = 0
while i < 10 :
  if c[i] >= 3 : #triplete 조사 후 데이터 삭제
    c[i] -= 3
    tri += 1
    continue
  if c[i] >= 1 and c[i+1] >= 1 and c[i+2] >= 1:
    c[i] -= 1
    c[i+1] -= 1
    c[i+2] -= 1
    run += 1
    continue
  i += 1

if run + tri == 2 : print('Baby Gin')
else : print('Lose')
```

## 숫자가 붙어서 입력이 들어올때

-ex)456789
  list(map(int, input()))
 split은 붙이면 안댐
'##############################'
for i in range(6):
    c[num % 10] += 1
    num //= 10

```python
import sys
# open 함수의 인자로 들어가는
# 문자열은 내가 열고자 하는 파일의 '경로'와 이름입니다.
sys.stdin = open('./input.txt')

T = int(input()) #test - case
for tc in range(1, T+1):
    A = list(map(int, input())) #입력 배열
    C = [0]*10 # 배열 생성
    for x in range(0, len(A)): # 카운트 배열
        C[A[x]] += 1
    print(C)
    # for x in range(1, len(C)): # 누적 카운트 배열
    #     C[x] += C[x-1]
    # # print(C)
    # #
    # B = [0]*6 # 입력 배열과 길이가 같은 배열 생성
    # for x in range(len(B)-1, -1, -1):
    #     C[A[x]] -= 1
    #     B[C[A[x]]] = A[x]
    # print(B)
    # B.append(0)
    # B.append(0)
```